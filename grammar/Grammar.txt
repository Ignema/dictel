
T = {add,acf,aco}
NT = {S,KEY,VALUE,TYPE }
Axiome : { S}

# **Some tokens definitions :**

ID ⇒ lettre {lettre | chiffre}
NUM ⇒ chiffre {chiffre}
Chiffre ⇒ 0|..|9
Lettre ⇒ a|b|..|z|A|..|Z
chaine ⇒ {lettre | chiffre | symbole}

acf = '{'
aco = '}'

# ** La grammaire P **:

S => ADD { ADD }
ADD => add ( KEY VALUE TYPE STATE ALLOCATE )
----------------------------------------------------------
KEY => lettre{lettre|chiffre|symbole}
-----------------------------------------------
VALUE => epsilon
      => , EXPR
      => , [ EXPR { , EXPR } ]                                            //array
      => , []
      => , (PARMS) => aco INTS acf                                       //functions
      => , ( CONDITION ) ? aco INSTS acf  : aco INSTS acf                 //if
      => , ( AFFEC { , AFFEC} ) => aco ID -> TYPES { ID -> TYPES } acof  //struct
PARMS => epsilon|MOT{,MOT}
---------------------------------------------
TYPE  => epsilon | , type = " TYPES {[]} "
STATE => epsilon | , state = " immutable|nonNullable|nullable "
KIND  => epsilon | ,kind="if|for|when|struct"
USE   => epsilon | , use = NUM 
RUN   => epsilon | , run="asynchronous|synchronous"	
ALLOCATE => epsilon |, allocate = " chiffre * sizeof ( TYPES ) "
-------------------------------------------------------------------------------------------
TYPES => void | char | short | int | long | float | double | signed | unsigned | string | pipe
---------------------------------------------------------------------------------------
INSTS => INST { INST }
INST  => epsilon | WRITE | READ | BLOCIF | BLOCFOR | BLOCWHILE | AFFEC | ADD |RETURN | break | WHENINST
----------------------------------------------------------
WRITE  => log( " { chaine aco $ aco ID acf {chaine}  } " | ID )
READ    => ID = scan()
BLOCIF  => if ( CONDITION ) aco INSTS acf
	=> if ( CONDITION ) ? aco INSTS acf : aco INSTS acf
AFFEC   => KEY = EXPR
BLOCFOR ⇒ for (AFFEC , CONDITION , INST)
BLOCWHILE ⇒  while ( CONDITION ) aco INSTS acof
WHENINST => NUM -> INST 
RETURN => return EXPR 
-----------------------------------------------------------------------------
CONDITION  => EXPR RELOP EXPR
RELOP => = | <> | < | > | <= | >=
EXPR => TERM { ADDOP TERM }
ADDOP => + | -
TERM => FACT { MULOP FACT }
MULOP => * | /
FACT => ID | NUM | ( EXPR )
----------------------------------------------------------------------

