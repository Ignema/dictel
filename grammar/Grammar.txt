

Axiome : { S}

# **Some tokens definitions :**

ID ⇒ lettre {lettre | chiffre}
NUM ⇒ chiffre {chiffre}
Chiffre ⇒ 0|..|9
Lettre ⇒ a|b|..|z|A|..|Z
chaine ⇒ {lettre | chiffre | symbole}
acf = '{'
aco = '}'

# ** La grammaire P **:

S => ADD { ADD }
ADD => add ( KEY VALUE TYPE STATE ALLOCATE )
----------------------------------------------------------
KEY => lettre{lettre|chiffre|symbole}
-----------------------------------------------
VALUE => ,V | epsilon 
  V   =>  EXPR
      => [ARRAY]
      =>  NUM..NUM            //range                                          
      => FUNCTION                                        
      => IFDEF 
      => FORDEF                
      => STRUCT 

ARRAY =>  EXPR { , EXPR } | epsilon 
FUNCTION => (PARMS) => aco INSTS acf 
IFDEF    => ( CONDITION ) ? aco INSTS acf  : aco INSTS acf  
FORDEF   => (ID) => aco INSTS acf  
STRUCT   => ( AFFEC { , AFFEC} ) => aco ID -> TYPES { ID -> TYPES } acof  
                                                      
PARMS => epsilon| ID { , ID }
---------------------------------------------
TYPE  => epsilon | , type = " TYPES {[]} "
STATE => epsilon | , state = " S "
S    => immutable|nonNullable|nullable
KIND  => epsilon | ,kind=" K "
K => if|for|when|struct
USE   => epsilon | , use = NUM 
RUN   => epsilon | , run=" R "
R => asynchronous|synchronous	
ALLOCATE => epsilon |, allocate = " chiffre * sizeof ( TYPES ) "
-------------------------------------------------------------------------------------------
TYPES => void | char | short | int | long | float | double | signed | unsigned | string | pipe
---------------------------------------------------------------------------------------
INSTS => INST { INST }
INST  => epsilon | WRITE | READ | BLOCIF | BLOCFOR | BLOCWHILE | AFFEC | ADD |RETURN | break | WHENINST | PARINST
----------------------------------------------------------
WRITE  => log( " { chaine aco $ aco ID acf {chaine}  } " | ID )
READ    => ID = scan()
BLOCIF  => if ( CONDITION ) aco INSTS acf
	=> CONDITION ? aco INSTS acf : aco INSTS acf
AFFEC   => KEY = EXPR
BLOCFOR ⇒ for (AFFEC , CONDITION , INST)
BLOCWHILE ⇒  while ( CONDITION ) aco INSTS acof
WHENINST => NUM -> INST 
RETURN => return EXPR 
PARINST => params ( ID )
-----------------------------------------------------------------------------
CONDITION  => EXPR RELOP EXPR
RELOP => = | <> | < | > | <= | >=
EXPR => TERM { ADDOP TERM }
ADDOP => + | -
TERM => FACT { MULOP FACT }
MULOP => * | /
FACT => ID | NUM | ( EXPR )
----------------------------------------------------------------------

